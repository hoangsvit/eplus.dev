---
title: "Module quiz: Introduction to algorithms"
seoTitle: "Module quiz: Introduction to algorithms"
seoDescription: "Module quiz: Introduction to algorithms"
datePublished: Sun Oct 06 2024 06:35:15 GMT+0000 (Coordinated Universal Time)
cuid: cm1x7l1iw000409l8030b32o7
slug: module-quiz-introduction-to-algorithms
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1728196481568/59fcfa01-5c94-4c46-9b00-316d00af2a19.png
ogImage: https://cdn.hashnode.com/res/hashnode/image/upload/v1728196496445/4ea2c7ce-9958-49e4-9e82-caad407cc33e.png

---

1. **Insertion sort is an example of divide and conquer?**
    
    * True
        
    * <mark>False</mark>
        
2. **Given an array of 6 numbers** `[6,8,19,48,9,90]` **and applying** `insertion sort`***,* how many swaps must occur before the array is sorted?**
    
    * 6
        
    * <mark>2</mark>
        
    * 4
        
3. **What time complexity is required to do a linear search?**
    
    * O(1)
        
    * <mark>O(n)</mark>
        
    * ((log (n))
        
4. **Why do we need Big-O notation to evaluate our programs?**
    
    * Because sorting is complicated, and we need a complicated metric.
        
    * Because sorting requires that things are moved around to save space.
        
    * <mark>Because measuring time is relative to a personâ€™s computer, so a relative metric is required.</mark>
        
5. **What is parallelization?**
    
    * <mark>It is about running code at the same time in threads or on separate computers.</mark>
        
    * It is about calling functions repetitively until they have achieved a base case.
        
    * It is about writing your code in one go.
        
6. **Why would you decide to use recursion?**
    
    * It looks cool and makes your code seem more intelligent.
        
    * Recursion reduces the pressure on the compiler by making less stack calls.
        
    * <mark>It lends itself well to a divide and conquer approach.</mark>
        
7. **Why does Memoization work well with dynamic programming?**
    
    * It takes up less space in the hard drive.
        
    * <mark>It requires less compiling because it stores previous results, reducing the load on the CPU.</mark>
        
    * Because it takes a lot of memory to run some programs and memoization allows you to store data in smaller sizes.
        
8. **How are the principles of dynamic programming and greedy algorithms at odds with one another?**
    
    * <mark>The principle of dynamic programming is to exhaustively compute the best solution, while a greedy approach will favor take the immediate best option.</mark>
        
    * Because dynamic programming will react with more agility to a program, while the greedy approach will be slower and more self-centered.
        
    * The greedy algorithm will use up CPU by monopolizing resources.
        
9. **Why is a binary search conducted in** `O(log n)` **time?**
    
    * <mark>Regardless of the size of the input, at every step the number of calculations is halved.</mark>
        
    * It is not, it is conducted in O(n).
        
    * Because as it searches it sorts the elements.
        

![Fibonacci number](https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/wYaWqRRLSQus1NsmnTFanw_b957e40146914d64a52641a8d1f5fde1_image.png?expiry=1728345600000&hmac=kKZjfgt2A71Tvpg1_wSm0_hH2unKPdG0R-hKmp8OKQ4 align="left")

**In the Fibonacci pseudocode above how many recursive instances can be seen?**

* 0
    
* 1
    
* <mark>2</mark>
    

---

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1728196475796/19d5f95f-6751-4bc8-8bb2-1386960fb5d7.png align="center")